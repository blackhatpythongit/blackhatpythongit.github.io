<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>First blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Write something">
<meta property="og:type" content="website">
<meta property="og:title" content="First blog">
<meta property="og:url" content="https://blackhatpythongit.github.io/index.html">
<meta property="og:site_name" content="First blog">
<meta property="og:description" content="Write something">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="First blog">
<meta name="twitter:description" content="Write something">
  
    <link rel="alternate" href="/atom.xml" title="First blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">First blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Learning notes</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blackhatpythongit.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Git" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/21/Git/" class="article-date">
  <time datetime="2016-08-21T10:25:23.000Z" itemprop="datePublished">2016-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/21/Git/">Git</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <script src="https://bramp.github.io/js-sequence-diagrams/js/raphael-min.js"></script>
<script src="https://bramp.github.io/js-sequence-diagrams/js/underscore-min.js"></script>
<script src="https://bramp.github.io/js-sequence-diagrams/js/sequence-diagram-min.js"></script>

<p><a href="http://ndpsoftware.com/git-cheatsheet.html" target="_blank" rel="external">Visual Git Cheat Sheet</a></p>
<h2 id="文件的状态及文件状态的转换"><a href="#文件的状态及文件状态的转换" class="headerlink" title="文件的状态及文件状态的转换"></a>文件的状态及文件状态的转换</h2><div id="diagram1"></div>

<h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><div id="diagram2"></div>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">git add &lt;file&gt;...				# 使staging area变得和working directory一样</div><div class="line">git checkout -- &lt;file&gt;...		# 使working directory变得和staging area一样</div><div class="line"></div><div class="line">git commit						# 使local repository变得和staging area一样</div><div class="line">git reset HEAD &lt;file&gt;			# 使staging area变得和local repository一样</div><div class="line"></div><div class="line">git commit -a					# 使staging area和local repository变得和working directory一样</div><div class="line">git reset --hard HEAD			# 使working directory和staging area和变得和local repository一样</div><div class="line"></div><div class="line"># HEAD可以是[head, head^, head^^, ... head~100, commit_id]</div></pre></td></tr></table></figure>
<script>
    var diagram = Diagram.parse("Untracked->Staged: Add the file\r\n\
        Unmodified->Modified: Edit the file\r\n\
        Modified->Staged: Stage the file\r\n\
        Staged->Unmodified: Commit\r\n\
        Unmodified->Untracked: Remove the file");
    diagram.drawSVG("diagram1", {theme: 'simple'});

    var diagram = Diagram.parse("working directory->staging area: git add <file>...\r\n\
        staging area->working directory: git checkout -- <file>...\r\n\
        staging area->local repository: git commit\r\n\
        local repository->staging area: git reset HEAD <file>\r\n\
        working directory->local repository: git commit -a\r\n\
        local repository->working directory: git reset --hard HEAD");
    diagram.drawSVG("diagram2", {theme: 'simple'});
</script>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blackhatpythongit.github.io/2016/08/21/Git/" data-id="cis4sr66t0000lwhm818gn7ps" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ctypes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/13/ctypes/" class="article-date">
  <time datetime="2016-08-13T07:13:46.000Z" itemprop="datePublished">2016-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/13/ctypes/">ctypes tutorial</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-加载动态链接库"><a href="#1-加载动态链接库" class="headerlink" title="1. 加载动态链接库"></a>1. 加载动态链接库</h2><p>通过访问cdll、windll、oledll的属性来加载库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; print windll.kernel32</div><div class="line">&lt;WinDLL &apos;kernel32&apos;, handle 759a0000 at 27aacf0&gt;</div><div class="line">&gt;&gt;&gt; print cdll.msvcrt</div><div class="line">&lt;CDLL &apos;msvcrt&apos;, handle 77770000 at 2799a10&gt;</div><div class="line">&gt;&gt;&gt; libc = cdll.msvcrt</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Windows会自动添加.dll后缀。<br>在Linux系统，要求指定包含扩展名的文件名来导入库，所以访问属性的方法不能用于加载库。要么使用dll加载器的LoadLibrary()方法，要么通过调用构造函数来创建一个CDLL的实例来加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; cdll.LoadLibrary(&quot;libc.so.6&quot;)</div><div class="line">&lt;CDLL &apos;libc.so.6&apos;, handle 7f566584a000 at 7f5665706110&gt;</div><div class="line">&gt;&gt;&gt; libc = CDLL(&quot;libc.so.6&quot;)</div><div class="line">&gt;&gt;&gt; libc</div><div class="line">&lt;CDLL &apos;libc.so.6&apos;, handle 7f566584a000 at 7f5665706450&gt;</div></pre></td></tr></table></figure>
<h2 id="2-访问已加载dll的函数"><a href="#2-访问已加载dll的函数" class="headerlink" title="2. 访问已加载dll的函数"></a>2. 访问已加载dll的函数</h2><p>通过dll对象的属性访问函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; libc.printf</div><div class="line">&lt;_FuncPtr object at 0x7f5663c891f0&gt;</div><div class="line">&gt;&gt;&gt; print windll.kernel32.GetModuleHandleA</div><div class="line">&lt;_FuncPtr object at 0x026A87B0&gt;</div><div class="line">&gt;&gt;&gt; print windll.kernel32.MyOwnFunction</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 375, in __getattr__</div><div class="line">    func = self.__getitem__(name)</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 380, in __getitem__</div><div class="line">    func = self._FuncPtr((name_or_ordinal, self))</div><div class="line">AttributeError: function &apos;MyOwnFunction&apos; not found</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>要自己确定调用GetModuleHandleA还是GetModuleHandleW。<br>函数名如果不是Python的合法标识符，可以用getattr()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(cdll.msvcrt, &quot;??2@YAPAXI@Z&quot;)</div><div class="line">&lt;_FuncPtr object at 0x026A8828&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>在Windows系统，一些dll不是通过名字而是通过序数来导出函数。可以通过使用序数来索引dll对象来访问这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; cdll.kernel32[1]</div><div class="line">&lt;_FuncPtr object at 0x026787B0&gt;</div><div class="line">&gt;&gt;&gt; cdll.kernel32[0]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 380, in __getitem__</div><div class="line">    func = self._FuncPtr((name_or_ordinal, self))</div><div class="line">AttributeError: function ordinal 0 not found</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="3-调用函数"><a href="#3-调用函数" class="headerlink" title="3. 调用函数"></a>3. 调用函数</h2><p>你可以像调用任何其他Python可调用的xxx调用这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print libc.time(None)</div><div class="line">1471001186</div><div class="line">&gt;&gt;&gt; print hex(windll.kernel32.GetModuleHandleA(None))</div><div class="line">0x1c7e0000</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>ctypes尝试阻止你使用错误数量的参数和错误的调用约定来调用函数。不幸的是这只在Windows下有效。这通过检查函数返回后的栈来实现，所以虽然报错但是函数已经被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with not enough arguments (4 bytes missing)</div><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(0, 0)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with too many arguments (4 bytes in excess)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; cdll.kernel32.GetModuleHandleA(None)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure called with not enough arguments (4 bytes missing) or wron</div><div class="line">g calling convention</div><div class="line">&gt;&gt;&gt; windll.msvcrt.printf(&quot;spam&quot;)</div><div class="line">spamTraceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with too many arguments (4 bytes in excess</div><div class="line">)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>On Windows, ctypes uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(32)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">WindowsError: exception: access violation reading 0x00000020</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>只有None, integer, long, byte string和unicode string是可以直接用作这些函数参数的Python原生对象。None被传为C的NULL指针，byte string和unicode strings被传为指向含有它们数据的内存块的指针(char <em>或者wchar_t </em>)。integer和long被传为平台默认的C语言int类型，它们的值被调整来适应C类型。</p>
<h2 id="4-基本数据类型"><a href="#4-基本数据类型" class="headerlink" title="4. 基本数据类型"></a>4. 基本数据类型</h2><table>
<thead>
<tr>
<th style="text-align:left">ctypes type</th>
<th style="text-align:left">Ctype</th>
<th style="text-align:left">Python type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">c_bool</td>
<td style="text-align:left">_Bool</td>
<td style="text-align:left">bool(1)</td>
</tr>
<tr>
<td style="text-align:left">c_char</td>
<td style="text-align:left">char</td>
<td style="text-align:left">1-character string</td>
</tr>
<tr>
<td style="text-align:left">c_wchar</td>
<td style="text-align:left">wchar_t</td>
<td style="text-align:left">1-character unicode string</td>
</tr>
<tr>
<td style="text-align:left">c_byte</td>
<td style="text-align:left">char</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ubyte</td>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_short</td>
<td style="text-align:left">short</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ushort</td>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_int</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_uint</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_long</td>
<td style="text-align:left">long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ulong</td>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_longlong</td>
<td style="text-align:left">__int64 or long long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ulonglong</td>
<td style="text-align:left">unsigned __int64 or unsigned long long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_float</td>
<td style="text-align:left">float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_double</td>
<td style="text-align:left">double</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_longdouble</td>
<td style="text-align:left">long double</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_char_p</td>
<td style="text-align:left">char * (NUL terminated)</td>
<td style="text-align:left">string or None</td>
</tr>
<tr>
<td style="text-align:left">c_wchar_p</td>
<td style="text-align:left">wchar_t * (NUL terminated)</td>
<td style="text-align:left">unicode or None</td>
</tr>
<tr>
<td style="text-align:left">c_void_p</td>
<td style="text-align:left">void *</td>
<td style="text-align:left">int/long or None</td>
</tr>
</tbody>
</table>
<ol>
<li>构造函数接受任何with a truth value的对象</li>
</ol>
<p>All these types can be created by calling them with an optional initializer of the correct type and value:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c_int()</div><div class="line">c_long(0)</div><div class="line">&gt;&gt;&gt; c_char_p(&quot;Hello, World&quot;)</div><div class="line">c_char_p(&apos;Hello, World&apos;)</div><div class="line">&gt;&gt;&gt; c_ushort(-3)</div><div class="line">c_ushort(65533)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>值可变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int(42)</div><div class="line">&gt;&gt;&gt; print i</div><div class="line">c_long(42)</div><div class="line">&gt;&gt;&gt; print i.value</div><div class="line">42</div><div class="line">&gt;&gt;&gt; i.value = -99</div><div class="line">&gt;&gt;&gt; print i.value</div><div class="line">-99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>给指针类型(c_char_p, c_wchar_p和c_void_p)的实例赋新值，会改变指针的指向，不改变内存块的内容(当然不，因为Python的string是不可变的)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;Hello, World&quot;</div><div class="line">&gt;&gt;&gt; c_s = c_char_p(s)</div><div class="line">&gt;&gt;&gt; print c_s</div><div class="line">c_char_p(&apos;Hello, World&apos;)</div><div class="line">&gt;&gt;&gt; c_s.value = &quot;Hi, there&quot;</div><div class="line">&gt;&gt;&gt; print c_s</div><div class="line">c_char_p(&apos;Hi, there&apos;)</div><div class="line">&gt;&gt;&gt; print s					# first string is unchanged</div><div class="line">Hello, World</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>但是，你要小心，不要把它们传给期望指向可变内存的指针的函数。ctypes的create_string_buffer()函数可以以多种方式创建指向可变内存的指针。目前内存块的内容可以通过raw属性访问(或修改)。如果你想以NUL结尾的string访问，使用value属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; p = create_string_buffer(3)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">3 &apos;\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">6 &apos;Hello\x00&apos;</div><div class="line">&gt;&gt;&gt; print repr(p.value)</div><div class="line">&apos;Hello&apos;</div><div class="line">&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;, 10)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">10 &apos;Hello\x00\x00\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt; p.value = &quot;Hi&quot;</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">10 &apos;Hi\x00lo\x00\x00\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>对应的是create_unicode_buffer()</p>
<h2 id="5-函数调用续"><a href="#5-函数调用续" class="headerlink" title="5. 函数调用续"></a>5. 函数调用续</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf = libc.printf</div><div class="line">&gt;&gt;&gt; printf(&quot;Hello, %s\n&quot;, &quot;World!&quot;)</div><div class="line">Hello, World!</div><div class="line">14</div><div class="line">&gt;&gt;&gt; printf(&quot;Hello, %S\n&quot;, u&quot;World!&quot;)</div><div class="line">Hello, World!</div><div class="line">14</div><div class="line">&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, 42)</div><div class="line">42 bottles of beer</div><div class="line">19</div><div class="line">&gt;&gt;&gt; printf(&quot;%f bottles of beer\n&quot;, 42.5)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: Don&apos;t know how to convert parameter 2</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>正如之前提到的，除了integer, string, unicode string以外所有Python类型必须被封装成对应的ctypes类型，这样它们可以被转换为需要的C数据类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf(&quot;An int %d, a double %f\n&quot;, 1234, c_double(3.14))</div><div class="line">An int 1234, a double 3.140000</div><div class="line">31</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="6-使用自定义的数据类型调用函数"><a href="#6-使用自定义的数据类型调用函数" class="headerlink" title="6. 使用自定义的数据类型调用函数"></a>6. 使用自定义的数据类型调用函数</h2><p>你也可以自定义参数转换来允许你的类的实例被用作函数参数。ctypes寻找_as<em>parameter</em>属性，并用这个当作函数参数。当然，它必须是integer, string, unicode之一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Bottles(object):</div><div class="line">...     def __init__(self, number):</div><div class="line">...             self._as_parameter_ = number</div><div class="line">... </div><div class="line">&gt;&gt;&gt; bottles = Bottles(42)</div><div class="line">&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, bottles)</div><div class="line">42 bottles of beer</div><div class="line">19</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="7-指定需要的参数类型-函数原型"><a href="#7-指定需要的参数类型-函数原型" class="headerlink" title="7. 指定需要的参数类型(函数原型)"></a>7. 指定需要的参数类型(函数原型)</h2><p>通过设置argtypes属性来指定从DLL导出的函数的参数类型是可能的。argtypes必须是C数据类型的序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf.argtypes = [c_char_p, c_char_p, c_int, c_double]</div><div class="line">&gt;&gt;&gt; printf(&quot;String &apos;%s&apos;, Int %d, Double %f\n&quot;, &quot;Hi&quot;, 10, 2.2)</div><div class="line">String &apos;Hi&apos;, Int 10, Double 2.200000</div><div class="line">37</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指定形式可以防止不兼容参数类型(就像C函数的原型)，并且尝试转换参数为合法的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf(&quot;%d %d %d&quot;, 1, 2, 3)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: wrong type</div><div class="line">&gt;&gt;&gt; printf(&quot;%s %d %f\n&quot;, &quot;X&quot;, 2, 3)</div><div class="line">X 2 3.000000</div><div class="line">13</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>If you have defined your own classes which you pass to function calls, you have to implement a from_param() class method for them to be able to use them in the argtypes sequence. The from_param() class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its _as<em>parameter</em> attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, unicode, a ctypes instance, or an object with an _as<em>parameter</em> attribute.</p>
<h2 id="8-返回类型"><a href="#8-返回类型" class="headerlink" title="8. 返回类型"></a>8. 返回类型</h2><p>默认认为函数返回int类型。其他返回类型可以通过设置函数对象的restype属性来指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; strchr = libc.strchr</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))</div><div class="line">1701862487</div><div class="line">&gt;&gt;&gt; strchr.restype = c_char_p</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, ord(&quot;x&quot;))</div><div class="line">None</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>如果你想要避免上面的ord(“x”)调用，你可以设置argtypes属性，第二个参数从一个字符的Python string转换成一个C语言char:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; strchr.restype = c_char_p</div><div class="line">&gt;&gt;&gt; strchr.argtypes = [c_char_p, c_char]</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;def&quot;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: wrong type</div><div class="line">&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, &quot;x&quot;)</div><div class="line">None</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>你也可以使用一个可调用的Python对象(一个函数或一个类)作为restype的属性，如果外部函数返回一个整数。可调用对象的会被调用(使用C函数返回的整数作为参数)这个调用的结果会作为函数调用的结果。这对检查错误返回值和自动引发异常很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA</div><div class="line">&gt;&gt;&gt; def ValidHandle(value):</div><div class="line">...     if value == 0:</div><div class="line">...             raise WinError()</div><div class="line">...     return value</div><div class="line">...</div><div class="line">&gt;&gt;&gt; GetModuleHandle.restype = ValidHandle</div><div class="line">&gt;&gt;&gt; GetModuleHandle(None)</div><div class="line">478019584</div><div class="line">&gt;&gt;&gt; GetModuleHandle(&quot;something silly&quot;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in ValidHandle</div><div class="line">WindowsError: [Error 126] 找不到指定的模块。</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>WinError is a function which will call Windows FormatMessage() api to get the string representation of an error code, and returns an exception. WinError takes an optional error code parameter, if no one is used, it calls GetLastError() to retrieve it.</p>
<p>Please note that a much more powerful error checking mechanism is available through the errcheck attribute; see the reference manual for details.</p>
<h2 id="9-传递指针-或者按引用传参"><a href="#9-传递指针-或者按引用传参" class="headerlink" title="9. 传递指针(或者按引用传参)"></a>9. 传递指针(或者按引用传参)</h2><p>ctypes导出byref()函数用于按引用传参。pointer()函数可以达到同样的效果，虽然pointer会做许多更多的工作，因为它会构造一个真的指针对象，所以如果你在python中不需要指针对象，用byref()更快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int()</div><div class="line">&gt;&gt;&gt; f = c_float()</div><div class="line">&gt;&gt;&gt; s = create_string_buffer(&quot;\000&quot; * 32)</div><div class="line">&gt;&gt;&gt; print i.value, f.value, repr(s.value)</div><div class="line">0 0.0 &apos;&apos;</div><div class="line">&gt;&gt;&gt; libc.sscanf(&quot;1 3.14 Hello&quot;, &quot;%d %f %s&quot;, byref(i), byref(f), s)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; print i.value, f.value, repr(s.value)</div><div class="line">1 3.1400001049 &apos;Hello&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="10-结构体和联合"><a href="#10-结构体和联合" class="headerlink" title="10. 结构体和联合"></a>10. 结构体和联合</h2><p>结构体和联合一定是从ctypes定义的Structure和Union基类衍生而来。每个子类一定要定义<em>fields</em>属性。<em>fields</em>一定是两个元组的列表，包含字段名和字段类型。</p>
<p>字段类型一定是ctypes类型比如c_int或者其他ctypes衍生类型:structure, union, array, pointer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = [(&quot;x&quot;, c_int),</div><div class="line">...                 (&quot;y&quot;, c_int)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; point = POINT(10, 20)</div><div class="line">&gt;&gt;&gt; print(point.x, point.y)</div><div class="line">(10, 20)</div><div class="line">&gt;&gt;&gt; point = POINT(y=5)</div><div class="line">&gt;&gt;&gt; print(point.x, point.y)</div><div class="line">(0, 5)</div><div class="line">&gt;&gt;&gt; POINT(1, 2, 3)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: too many initializers</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>你可以将结构体作为字段类型来构造更复杂的结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = [(&quot;upperleft&quot;, POINT),]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = [(&quot;upperleft&quot;, POINT),</div><div class="line">...                 (&quot;lowerright&quot;, POINT)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; rc = RECT(point)</div><div class="line">&gt;&gt;&gt; print(rc.upperleft.x, rc.upperleft.y)</div><div class="line">(0, 5)</div><div class="line">&gt;&gt;&gt; print(rc.lowerright.x, rc.lowerright.y)</div><div class="line">(0, 0)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>嵌套的结构体可以以多种方式初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = RECT(POINT(1, 2), POINT(3, 4))</div><div class="line">&gt;&gt;&gt; r = RECT((1, 2), (3, 4))</div></pre></td></tr></table></figure></p>
<p>Field descriptors can be retrieved from the class, they are useful for debugging because they can provide useful information:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(POINT.x)</div><div class="line">&lt;Field type=c_long, ofs=0, size=4&gt;</div><div class="line">&gt;&gt;&gt; print(POINT.y)</div><div class="line">&lt;Field type=c_long, ofs=4, size=4&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Warning</p>
<p>ctypes does not support passing unions or structures with bit-fields to functions by value. While this may work on 32-bit x86, it’s not guaranteed by the library to work in the general case. Unions and structures with bit-fields should always be passed to functions by pointer. </p>
<h2 id="11-结构体-联合对齐和字节顺序"><a href="#11-结构体-联合对齐和字节顺序" class="headerlink" title="11. 结构体/联合对齐和字节顺序"></a>11. 结构体/联合对齐和字节顺序</h2><p>By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior be specifying a <em>pack</em> class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what #pragma pack(n) also does in MSVC.</p>
<p>ctypes uses the native byte order for Structures and Unions. To build structures with non-native byte order, you can use one of the BigEndianStructure, LittleEndianStructure, BigEndianUnion, and LittleEndianUnion base classes. These classes cannot contain pointer fields.</p>
<h2 id="12-结构体和联合中的bit字段"><a href="#12-结构体和联合中的bit字段" class="headerlink" title="12. 结构体和联合中的bit字段"></a>12. 结构体和联合中的bit字段</h2><p>创建含有bit字段的结构体和联合是可能的。只有对integer字段有可能，bit的宽带由<em>fields</em>元组的第三项指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Int(Structure):</div><div class="line">...     _fields_ = [(&quot;first_16&quot;, c_int, 16),</div><div class="line">...                 (&quot;second_16&quot;, c_int, 16)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print(Int.first_16)</div><div class="line">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</div><div class="line">&gt;&gt;&gt; print(Int.second_16)</div><div class="line">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="13-数组"><a href="#13-数组" class="headerlink" title="13. 数组"></a>13. 数组</h2><p>推荐的创建数组的方式是将一个数据类型乘以一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; TenPointsArrayType = POINT * 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class MyStruct(Structure):</div><div class="line">...     _fields_ = [(&quot;a&quot;, c_int),</div><div class="line">...                 (&quot;b&quot;, c_float),</div><div class="line">...                 (&quot;point_array&quot;, POINT * 4)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; print(len(MyStruct().point_array))</div><div class="line">4</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>调用类来创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = TenPointsArrayType()</div><div class="line">for pt in arr:</div><div class="line">    print(pt.x, pt.y)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; TenIntegers = c_int * 10</div><div class="line">&gt;&gt;&gt; ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</div><div class="line">&gt;&gt;&gt; print(ii)</div><div class="line">&lt;__main__.c_long_Array_10 object at 0x025A4490&gt;</div><div class="line">&gt;&gt;&gt; for i in ii: print i,</div><div class="line">...</div><div class="line">1 2 3 4 5 6 7 8 9 10</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="14-指针"><a href="#14-指针" class="headerlink" title="14. 指针"></a>14. 指针</h2><p>调用pointer()来创建指针实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; i = c_int(42)</div><div class="line">&gt;&gt;&gt; pi = pointer(i)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指针实例有contents属性来返回指针所指的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi.contents</div><div class="line">c_long(42)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>contents返回的不是原始对象，而是新构造的等价的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi.contents is i</div><div class="line">False</div><div class="line">&gt;&gt;&gt; pi.contents is pi.contents</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>给指针的contents属性赋予另一个c_int实例，会改变指针的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int(99)</div><div class="line">&gt;&gt;&gt; pi.contents = i</div><div class="line">&gt;&gt;&gt; pi.contents</div><div class="line">c_long(99)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指针对象也可以用整数索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi[0]</div><div class="line">99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>用索引赋值会改变指针指向的对象的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(i)</div><div class="line">c_long(99)</div><div class="line">&gt;&gt;&gt; pi[0] = 22</div><div class="line">&gt;&gt;&gt; print(i)</div><div class="line">c_long(22)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>pointer()不只是简单创建指针实例，它会先创建指针类型。通过调用POINTER()函数来完成。POINTER()接受任何ctypes类型，并返回新类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; PI = POINTER(c_int)</div><div class="line">&gt;&gt;&gt; PI</div><div class="line">&lt;class &apos;__main__.LP_c_long&apos;&gt;</div><div class="line">&gt;&gt;&gt; PI(42)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: expected c_long instead of int</div><div class="line">&gt;&gt;&gt; PI(c_int(42))</div><div class="line">&lt;__main__.LP_c_long object at 0x025A4530&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>不使用参数调用指针类型会创建NULL指针，NULL指针的布尔值是False。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; null_ptr = POINTER(c_int)()</div><div class="line">&gt;&gt;&gt; print(bool(null_ptr))</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>ctypes解引用指针时会检查指针是否为NULL(但是解引用非法的非空指针会使Python崩溃)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; null_ptr[0]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: NULL pointer access</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; null_ptr[0] = 1234</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: NULL pointer access</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="15-类型转换"><a href="#15-类型转换" class="headerlink" title="15. 类型转换"></a>15. 类型转换</h2><p>对于POINTER(c_int)，ctypes接受c_int数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Bar(Structure):</div><div class="line">...     _fields_ = [(&quot;count&quot;, c_int), (&quot;value&quot;, POINTER(c_int))]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bar = Bar()</div><div class="line">&gt;&gt;&gt; bar.values = (c_int * 3)(1, 2, 3)</div><div class="line">&gt;&gt;&gt; bar.count = 3</div><div class="line">&gt;&gt;&gt; for i in range(bar.count):</div><div class="line">...     print(bar.values[i])</div><div class="line">...</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>你可以赋值None来将指针类型的字段设置为NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bar.values = None</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>不兼容的类型会报错，可以使用cast()函数强制转换。cast()接受2个参数，一个ctypes对象是或者可以被转化为类似指针和一个ctypes指针类型。返回指向第一个参数所指内存的第二个参数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = (c_byte * 4)()</div><div class="line">&gt;&gt;&gt; cast(a, POINTER(c_int))</div><div class="line">&lt;__main__.LP_c_long object at 0x025A43F0&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="16-未完成类型"><a href="#16-未完成类型" class="headerlink" title="16. 未完成类型"></a>16. 未完成类型</h2><p>可以先定义类，再设置<em>fields</em>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class cell(Structure):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; cell._fields_ = [(&quot;name&quot;, c_char_p),</div><div class="line">...                  (&quot;next&quot;, POINTER(cell))]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c1 = cell()</div><div class="line">&gt;&gt;&gt; c1.name = &quot;foo&quot;</div><div class="line">&gt;&gt;&gt; c2 = cell()</div><div class="line">&gt;&gt;&gt; c2.name = &quot;bar&quot;</div><div class="line">&gt;&gt;&gt; c1.next = pointer(c2)</div><div class="line">&gt;&gt;&gt; c2.next = pointer(c1)</div><div class="line">&gt;&gt;&gt; p = c1</div><div class="line">&gt;&gt;&gt; for i in range(8):</div><div class="line">...     print p.name,</div><div class="line">...     p = p.next[0]</div><div class="line">...</div><div class="line">foo bar foo bar foo bar foo bar</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="17-回调函数"><a href="#17-回调函数" class="headerlink" title="17. 回调函数"></a>17. 回调函数</h2><p>ctypes允许从Python可调用对象创建C可调用函数指针。有时叫回调函数。<br>首先，你一定要为回调函数创建一个类。该类知道调用约定，返回类型，参数数量和类型。<br>CFUNCTYPE()工厂函数创建使用cdecl调用约定的回调函数。<br>WINFUNCTYPE()工厂函数创建使用stdcall调用约定的回调函数。<br>这些工厂函数使用结果类型作为第一个参数，参数类型作为剩下的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; IntArray5 = c_int * 5</div><div class="line">&gt;&gt;&gt; ia = IntArray5(5, 1, 7, 33, 99)</div><div class="line">&gt;&gt;&gt; qsort = libc.qsort</div><div class="line">&gt;&gt;&gt; qsort.restype = None</div><div class="line">&gt;&gt;&gt; </div><div class="line">&gt;&gt;&gt; CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</div><div class="line">&gt;&gt;&gt; def py_cmp_func(a, b):</div><div class="line">...     print(&quot;py_cmp_func&quot;, a[0], b[0])</div><div class="line">...     return a[0] - b[0]</div><div class="line">... </div><div class="line">&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))</div><div class="line">(&apos;py_cmp_func&apos;, 5, 1)</div><div class="line">(&apos;py_cmp_func&apos;, 33, 99)</div><div class="line">(&apos;py_cmp_func&apos;, 7, 33)</div><div class="line">(&apos;py_cmp_func&apos;, 1, 7)</div><div class="line">(&apos;py_cmp_func&apos;, 5, 7)</div><div class="line">&gt;&gt;&gt; for i in ia: print i,</div><div class="line">... </div><div class="line">1 5 7 33 99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>Note: Make sure you keep references to CFUNCTYPE() objects as long as they are used from C code. ctypes doesn’t, and if you don’t, they may be garbage collected, crashing your program when a callback is made.</p>
<p>Also, note that if the callback function is called in a thread created outside of Python’s control (e.g. by the foreign code that calls the callback), ctypes creates a new dummy Python thread on every invocation. This behavior is correct for most purposes, but it means that values stored with threading.local will not survive across different callbacks, even when those calls are made from the same C thread.</p>
<h2 id="18-访问dll导出的值"><a href="#18-访问dll导出的值" class="headerlink" title="18. 访问dll导出的值"></a>18. 访问dll导出的值</h2><p>Some shared libraries not only export functions, they also export variables. An example in the Python library itself is the Py_OptimizeFlag, an integer set to 0, 1, or 2, depending on the -O or -OO flag given on startup.</p>
<p>ctypes can access values like this with the in_dll() class methods of the type. pythonapi is a predefined symbol giving access to the Python C api:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; opt_flag = c_int.in_dll(pythonapi, &quot;Py_OptimizeFlag&quot;)</div><div class="line">&gt;&gt;&gt; print(opt_flag)</div><div class="line">c_long(0)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>If the interpreter would have been started with -O, the sample would have printed c_long(1), or c_long(2) if -OO would have been specified.</p>
<p>An extended example which also demonstrates the use of pointers accesses the PyImport_FrozenModules pointer exported by Python.</p>
<p>Quoting the docs for that value:</p>
<pre><code>This pointer is initialized to point to an array of struct _frozen records, terminated by one whose members are all NULL or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules.
</code></pre><p>So manipulating this pointer could even prove useful. To restrict the example size, we show only how this table can be read with ctypes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; class struct_frozen(Structure):</div><div class="line">...     _fields_ = [(&quot;name&quot;, c_char_p),</div><div class="line">...                 (&quot;code&quot;, POINTER(c_ubyte)),</div><div class="line">...                 (&quot;size&quot;, c_int)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>We have defined the struct _frozen data type, so we can get the pointer to the table:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; FrozenTable = POINTER(struct_frozen)</div><div class="line">&gt;&gt;&gt; table = FrozenTable.in_dll(pythonapi, &quot;PyImport_FrozenModules&quot;)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Since table is a pointer to the array of struct_frozen records, we can iterate over it, but we just have to make sure that our loop terminates, because pointers have no size. Sooner or later it would probably crash with an access violation or whatever, so it’s better to break out of the loop when we hit the NULL entry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for item in table:</div><div class="line">...     if item.name is None:</div><div class="line">...         break</div><div class="line">...     print(item.name.decode(&quot;ascii&quot;), item.size)</div><div class="line">...</div><div class="line">_frozen_importlib 31764</div><div class="line">_frozen_importlib_external 41499</div><div class="line">__hello__ 161</div><div class="line">__phello__ -161</div><div class="line">__phello__.spam 161</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>The fact that standard Python has a frozen module and a frozen package (indicated by the negative size member) is not well known, it is only used for testing. Try it out with import <strong>hello</strong> for example.</p>
<h2 id="19-惊喜"><a href="#19-惊喜" class="headerlink" title="19. 惊喜"></a>19. 惊喜</h2><p>There are some edges in ctypes where you might expect something other than what actually happens.</p>
<p>Consider the following example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = (&quot;a&quot;, POINT), (&quot;b&quot;, POINT)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; p1 = POINT(1, 2)</div><div class="line">&gt;&gt;&gt; p2 = POINT(3, 4)</div><div class="line">&gt;&gt;&gt; rc = RECT(p1, p2)</div><div class="line">&gt;&gt;&gt; print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)</div><div class="line">1 2 3 4</div><div class="line">&gt;&gt;&gt; # now swap the two points</div><div class="line">&gt;&gt;&gt; rc.a, rc.b = rc.b, rc.a</div><div class="line">&gt;&gt;&gt; print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)</div><div class="line">3 4 3 4</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Hm. We certainly expected the last statement to print 3 4 1 2. What happened? Here are the steps of the rc.a, rc.b = rc.b, rc.a line above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; temp0, temp1 = rc.b, rc.a</div><div class="line">&gt;&gt;&gt; rc.a = temp0</div><div class="line">&gt;&gt;&gt; rc.b = temp1</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Note that temp0 and temp1 are objects still using the internal buffer of the rc object above. So executing rc.a = temp0 copies the buffer contents of temp0 into rc ‘s buffer. This, in turn, changes the contents of temp1. So, the last assignment rc.b = temp1, doesn’t have the expected effect.</p>
<p>Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn’t copy the sub-object, instead it retrieves a wrapper object accessing the root-object’s underlying buffer.</p>
<p>Another example that may behave different from what one would expect is this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = c_char_p()</div><div class="line">&gt;&gt;&gt; s.value = &quot;abc def ghi&quot;</div><div class="line">&gt;&gt;&gt; s.value</div><div class="line">&apos;abc def ghi&apos;</div><div class="line">&gt;&gt;&gt; s.value is s.value</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Why is it printing False? ctypes instances are objects containing a memory block plus some descriptors accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the contents of the object is stored. Accessing the contents again constructs a new Python object each time!</p>
<h2 id="20-大小可变的数据类型"><a href="#20-大小可变的数据类型" class="headerlink" title="20. 大小可变的数据类型"></a>20. 大小可变的数据类型</h2><p>ctypes对大小可变的数组和结构体提供一些支持。<br>resize()函数可以对已经存在的类型对象重新设置内存大小。对象是第一个参数，字节大小是第二个参数。不能将内存大小设置得比对象类型原始大小小，否则会引发ValueError错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; short_array = (c_short * 4)()</div><div class="line">&gt;&gt;&gt; print(sizeof(short_array))</div><div class="line">8</div><div class="line">&gt;&gt;&gt; resize(short_array, 4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: minimum size is 8</div><div class="line">&gt;&gt;&gt; resize(short_array, 32)</div><div class="line">&gt;&gt;&gt; sizeof(short_array)</div><div class="line">32</div><div class="line">&gt;&gt;&gt; sizeof(type(short_array))</div><div class="line">8</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>无法访问多出来的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; short_array[:]</div><div class="line">[0, 0, 0, 0]</div><div class="line">&gt;&gt;&gt; short_array[7]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">IndexError: invalid index</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>也可以通过使用Python的动态特性和在知道需要内存大小后(重新)定义数据类型来使用大小可变的数据类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blackhatpythongit.github.io/2016/08/13/ctypes/" data-id="cis4sr6720001lwhmgmxrm4n8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-恶意代码混淆技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/07/恶意代码混淆技术/" class="article-date">
  <time datetime="2016-08-07T10:33:46.000Z" itemprop="datePublished">2016-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/恶意代码混淆技术/">恶意代码混淆技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="代码混淆技术基本概念"><a href="#代码混淆技术基本概念" class="headerlink" title="代码混淆技术基本概念"></a>代码混淆技术基本概念</h2><p>Christian Collberg给出的代码混淆的定义：<br>若混淆变换T将程序P变成P’，保证P和P’具有相同的观察行为，且满足性质<br>1)若P不能终止或出错终止，则P’不能终止或出错终止；<br>2)除此之外P’必须和P具有相同的输出。</p>
<p>度量混淆变换优劣的三个指标：<br>1)强度(Potency)：混淆算法为程序所增加的复杂度；<br>2)弹性(Resilience)：混淆算法抵抗攻击的能力；<br>3)开销(Cost)：混淆算法给程序带来的额外开销。</p>
<p>代码混淆可分为静态混淆和动态混淆。<br>静态混淆：在程序投入使用之前对代码进行变换从而令源代码变得更复杂、更难于理解，在程序执行之前，代码已经固定下来，不会在发生变化了。<br>动态混淆：通过使用一些技术(包括压缩、加密等)会使代码在静态与执行时的形态有一定差异，其一般分为两个阶段：第一阶段在编译时执行，这是将对程序中需要保护的代码进行初始转换(对某些代码部分进行压缩和加密等操作)，并在程序中添加运行时代码转换器；第二阶段在程序运行时执行，通过调用运行时代码转换器，真正的代码才能被释放出来交付执行。<br>二者的区别在于动态混淆处理后的代码体在执行时需要调用运行时代码转换器释放真正的代码从而执行功能，而经过静态混淆的代码则不用。</p>
<h2 id="恶意代码中的代码混淆"><a href="#恶意代码中的代码混淆" class="headerlink" title="恶意代码中的代码混淆"></a>恶意代码中的代码混淆</h2><p>具有代表性的混淆变换技术有加壳技术、变形技术和虚拟机技术。</p>
<h3 id="加壳技术"><a href="#加壳技术" class="headerlink" title="加壳技术"></a>加壳技术</h3><p>加密的恶意代码主要由两部分组成：解密器(decryptor)和加密的代码体。在代码执行时，两部分同时加载至内存，解密器先取得执行权，对代码体进行解密，在执行恶意代码的功能代码。这种基本的自保护方法除了使用加密外，还包括压缩。</p>
<p>在恶意代码发展的历史中有三种比较有代表性的加壳技术：加密(Encrypted)、寡态(Oligomorphic)、多态(Polymorphic)。</p>
<h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>优点：早期的加密技术通过隐藏具有恶意性的代码隐藏了特征，导致恶意代码对于分析和检测有了一定的抵抗能力。<br>缺点：由于方法简单，对检测和分析并没造成太多的困难，虽然检测工具无法直接获取恶意代码体的特征信息，但恒定不变的解密器取代代码本身成为了新的特征。</p>
<p>为了解决固定解密器特征易被检测的问题，恶意代码编写者发明了寡态和多态技术。</p>
<h4 id="寡态"><a href="#寡态" class="headerlink" title="寡态"></a>寡态</h4><p>寡态技术需要在恶意代码中包含一个解密器库，每次执行完或传播的时候会随机的从库中选择一个解密器，重新对代码体进行加密并将新的解密器加载在加密后的代码上。</p>
<p>优点：通过替换解密器在一定程度上弥补了普通加密的缺陷，从而降低了被检测到的可能性、增加了分析难度。<br>缺点：由于解密器都是从解密库中选取的，并且库中的解密器都是没有变化的，所以应用特征码检测技术仍可相对较容易的检测出。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态技术是在加密的基础上对解密器使用了代码混淆的产物，在恶意代码代码上添加多态(突变)引擎，恶意代码通过引擎对解密器的变换可以产生无数的变种。</p>
<p>多态和寡态的比较：<br>多态对于寡态最大的优势在于寡态技术是在有限范围内选择不同的解密器，而多态则是恶意代码自己本身可以产生不同的解密器。</p>
<p>优点：通过突变引擎从而使解密器的形态千差万别，导致代码的物理形态各不相同，基本上每执行或传播一次就会改变一次，并且每次所产生的代码结果相似度并不明显，所以很难在静态时确定其特征。</p>
<p>缺点：在动态执行时，代码体总是会被还原至内存，对内存镜像的分析可以很有效的检测出恶意代码的存在。</p>
<p>补充：针对这种情况，之后出现的一种多重多态的加壳方法有效的抑制了对内存镜像的分析，恶意代码在执行的过程中并不会一次性的暴露所有代码内容和信息，并且在每段代码执行后该段代码又会被加密；除此之外，攻击者还会使用种种反分析手段，比如检测和攻击当前执行环境、时间炸弹等，这些手段可以使代码进行长期休眠，更甚者可以直接攻击当前虚拟环境导致环境崩溃，导致对代码进行动态分析的难度增大。</p>
<h3 id="变形技术"><a href="#变形技术" class="headerlink" title="变形技术"></a>变形技术</h3><p>变形技术又称”体多态(body-polymorphics)”，该方法通过直接对恶意代码体的代码进行混淆从而逃避分析。变形恶意代码一般是由两部分组成：代码体和变形引擎。</p>
<p>和多态的区别：<br>变形恶意代码是对整个代码体使用混淆技术，代码每传播一次，通过对变形引擎的调用代码体的代码就会改变一次，并且代码行为不会改变。</p>
<p>变形引擎需要完成反汇编、代码分析、代码变换、汇编，所以一般情况下，变形引擎的代码量占整个变形恶意代码总代码量的比例都比较高。</p>
<p>优点：变形恶意代码并不使用加解密，其通过各种代码混淆技术在代码体中添加或改变指令、指令顺序等，导致内存中每次出现的代码版本都是不相同，所以基于特征码的检测对其基本无效。并且已经出现的一些研究表明变形恶意代码的检测是NP-完全难的。<br>缺点：由于该技术在实现和代码调试时难度较大，所以当前出现的使用该技术额恶意代码数量并不多。</p>
<h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>目的：为了抵抗对内存镜像的分析，避免对代码进行静态分析提取语义。<br>基本思想：在操作系统加载恶意代码时，首先动态创建一个虚拟机执行环境emulator，动态解释并执行以字节码方式存在的恶意代码。<br>优点：由于代码的执行系统完全改变，一些基于静态分析获取程序语义的方法失效，具有高强度的迷惑性，是专门用来对抗逆向工程分析的。<br>缺点：该方法在通过虚拟机保证保护强度的同时，也牺牲了指令的执行时间以及存储空间。</p>
<h2 id="常用的混淆方法"><a href="#常用的混淆方法" class="headerlink" title="常用的混淆方法"></a>常用的混淆方法</h2><h3 id="垃圾指令插入-Dead-code-Insertion"><a href="#垃圾指令插入-Dead-code-Insertion" class="headerlink" title="垃圾指令插入(Dead-code Insertion)"></a>垃圾指令插入(Dead-code Insertion)</h3><h3 id="寄存器重分配-Register-Reassignment"><a href="#寄存器重分配-Register-Reassignment" class="headerlink" title="寄存器重分配(Register Reassignment)"></a>寄存器重分配(Register Reassignment)</h3><h3 id="子程序重排-Subroutine-Reordering"><a href="#子程序重排-Subroutine-Reordering" class="headerlink" title="子程序重排(Subroutine Reordering)"></a>子程序重排(Subroutine Reordering)</h3><h3 id="指令替换-Instruction-Substitution"><a href="#指令替换-Instruction-Substitution" class="headerlink" title="指令替换(Instruction Substitution)"></a>指令替换(Instruction Substitution)</h3><h3 id="指令重排-Code-Translation"><a href="#指令重排-Code-Translation" class="headerlink" title="指令重排(Code Translation)"></a>指令重排(Code Translation)</h3><h3 id="代码融合-Code-Integration"><a href="#代码融合-Code-Integration" class="headerlink" title="代码融合(Code Integration)"></a>代码融合(Code Integration)</h3><p>首先恶意代码会反编译宿主程序到一种可处理的形态，然后再把自己嵌入到代码中，实现“无缝”融合，再把整合后的代码编译成文件，实现隐藏。由于该方法的精妙，检测和还原该种恶意代码的难度很大。</p>
<h2 id="恶意代码反混淆技术现状和展望"><a href="#恶意代码反混淆技术现状和展望" class="headerlink" title="恶意代码反混淆技术现状和展望"></a>恶意代码反混淆技术现状和展望</h2><h3 id="恶意代码反混淆技术现状"><a href="#恶意代码反混淆技术现状" class="headerlink" title="恶意代码反混淆技术现状"></a>恶意代码反混淆技术现状</h3><p>正规化<br>软件变换<br>项重写<br>binary rewriting</p>
<h3 id="恶意代码反混淆技术的挑战与发展趋势"><a href="#恶意代码反混淆技术的挑战与发展趋势" class="headerlink" title="恶意代码反混淆技术的挑战与发展趋势"></a>恶意代码反混淆技术的挑战与发展趋势</h3><p>反汇编的问题<br>找出直接对二进制文件进行反混淆变换的方法<br>对混淆技术的研究并不够全面<br>自动化的判断一段代码是否运用了混淆技术对于提高反混淆的效率有很大帮助<br>多重多态的加壳方法<br>如何应对恶意代码对环境的检测<br>通用脱壳器最大的问题在于低效性、无法解决具有环境检测功能的恶意代码、路径覆盖率会对脱壳结果有很大影响</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blackhatpythongit.github.io/2016/08/07/恶意代码混淆技术/" data-id="cis4sr67v0003lwhmzrxzw1l8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/06/hello-world/" class="article-date">
  <time datetime="2016-08-06T13:13:38.264Z" itemprop="datePublished">2016-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/06/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blackhatpythongit.github.io/2016/08/06/hello-world/" data-id="cis4sr6770002lwhmwcs9hzf2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/21/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2016/08/13/ctypes/">ctypes tutorial</a>
          </li>
        
          <li>
            <a href="/2016/08/07/恶意代码混淆技术/">恶意代码混淆技术</a>
          </li>
        
          <li>
            <a href="/2016/08/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Nob<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>