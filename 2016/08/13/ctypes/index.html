<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ctypes tutorial | First blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 加载动态链接库通过访问cdll、windll、oledll的属性来加载库
1234567&amp;gt;&amp;gt;&amp;gt; from ctypes import *&amp;gt;&amp;gt;&amp;gt; print windll.kernel32&amp;lt;WinDLL &amp;apos;kernel32&amp;apos;, handle 759a0000 at 27aacf0&amp;gt;&amp;gt;&amp;gt;&amp;gt; print cdll">
<meta property="og:type" content="article">
<meta property="og:title" content="ctypes tutorial">
<meta property="og:url" content="https://blackhatpythongit.github.io/2016/08/13/ctypes/index.html">
<meta property="og:site_name" content="First blog">
<meta property="og:description" content="1. 加载动态链接库通过访问cdll、windll、oledll的属性来加载库
1234567&amp;gt;&amp;gt;&amp;gt; from ctypes import *&amp;gt;&amp;gt;&amp;gt; print windll.kernel32&amp;lt;WinDLL &amp;apos;kernel32&amp;apos;, handle 759a0000 at 27aacf0&amp;gt;&amp;gt;&amp;gt;&amp;gt; print cdll">
<meta property="og:updated_time" content="2016-08-13T07:13:19.700Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ctypes tutorial">
<meta name="twitter:description" content="1. 加载动态链接库通过访问cdll、windll、oledll的属性来加载库
1234567&amp;gt;&amp;gt;&amp;gt; from ctypes import *&amp;gt;&amp;gt;&amp;gt; print windll.kernel32&amp;lt;WinDLL &amp;apos;kernel32&amp;apos;, handle 759a0000 at 27aacf0&amp;gt;&amp;gt;&amp;gt;&amp;gt; print cdll">
  
    <link rel="alternate" href="/atom.xml" title="First blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">First blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Learning notes</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blackhatpythongit.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ctypes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/13/ctypes/" class="article-date">
  <time datetime="2016-08-13T07:13:46.000Z" itemprop="datePublished">2016-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ctypes tutorial
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-加载动态链接库"><a href="#1-加载动态链接库" class="headerlink" title="1. 加载动态链接库"></a>1. 加载动态链接库</h2><p>通过访问cdll、windll、oledll的属性来加载库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; print windll.kernel32</div><div class="line">&lt;WinDLL &apos;kernel32&apos;, handle 759a0000 at 27aacf0&gt;</div><div class="line">&gt;&gt;&gt; print cdll.msvcrt</div><div class="line">&lt;CDLL &apos;msvcrt&apos;, handle 77770000 at 2799a10&gt;</div><div class="line">&gt;&gt;&gt; libc = cdll.msvcrt</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Windows会自动添加.dll后缀。<br>在Linux系统，要求指定包含扩展名的文件名来导入库，所以访问属性的方法不能用于加载库。要么使用dll加载器的LoadLibrary()方法，要么通过调用构造函数来创建一个CDLL的实例来加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; cdll.LoadLibrary(&quot;libc.so.6&quot;)</div><div class="line">&lt;CDLL &apos;libc.so.6&apos;, handle 7f566584a000 at 7f5665706110&gt;</div><div class="line">&gt;&gt;&gt; libc = CDLL(&quot;libc.so.6&quot;)</div><div class="line">&gt;&gt;&gt; libc</div><div class="line">&lt;CDLL &apos;libc.so.6&apos;, handle 7f566584a000 at 7f5665706450&gt;</div></pre></td></tr></table></figure>
<h2 id="2-访问已加载dll的函数"><a href="#2-访问已加载dll的函数" class="headerlink" title="2. 访问已加载dll的函数"></a>2. 访问已加载dll的函数</h2><p>通过dll对象的属性访问函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; libc.printf</div><div class="line">&lt;_FuncPtr object at 0x7f5663c891f0&gt;</div><div class="line">&gt;&gt;&gt; print windll.kernel32.GetModuleHandleA</div><div class="line">&lt;_FuncPtr object at 0x026A87B0&gt;</div><div class="line">&gt;&gt;&gt; print windll.kernel32.MyOwnFunction</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 375, in __getattr__</div><div class="line">    func = self.__getitem__(name)</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 380, in __getitem__</div><div class="line">    func = self._FuncPtr((name_or_ordinal, self))</div><div class="line">AttributeError: function &apos;MyOwnFunction&apos; not found</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>要自己确定调用GetModuleHandleA还是GetModuleHandleW。<br>函数名如果不是Python的合法标识符，可以用getattr()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; getattr(cdll.msvcrt, &quot;??2@YAPAXI@Z&quot;)</div><div class="line">&lt;_FuncPtr object at 0x026A8828&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>在Windows系统，一些dll不是通过名字而是通过序数来导出函数。可以通过使用序数来索引dll对象来访问这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; cdll.kernel32[1]</div><div class="line">&lt;_FuncPtr object at 0x026787B0&gt;</div><div class="line">&gt;&gt;&gt; cdll.kernel32[0]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;C:\Python27\lib\ctypes\__init__.py&quot;, line 380, in __getitem__</div><div class="line">    func = self._FuncPtr((name_or_ordinal, self))</div><div class="line">AttributeError: function ordinal 0 not found</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="3-调用函数"><a href="#3-调用函数" class="headerlink" title="3. 调用函数"></a>3. 调用函数</h2><p>你可以像调用任何其他Python可调用的xxx调用这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print libc.time(None)</div><div class="line">1471001186</div><div class="line">&gt;&gt;&gt; print hex(windll.kernel32.GetModuleHandleA(None))</div><div class="line">0x1c7e0000</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>ctypes尝试阻止你使用错误数量的参数和错误的调用约定来调用函数。不幸的是这只在Windows下有效。这通过检查函数返回后的栈来实现，所以虽然报错但是函数已经被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA()</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with not enough arguments (4 bytes missing)</div><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(0, 0)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with too many arguments (4 bytes in excess)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; cdll.kernel32.GetModuleHandleA(None)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure called with not enough arguments (4 bytes missing) or wron</div><div class="line">g calling convention</div><div class="line">&gt;&gt;&gt; windll.msvcrt.printf(&quot;spam&quot;)</div><div class="line">spamTraceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: Procedure probably called with too many arguments (4 bytes in excess</div><div class="line">)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>On Windows, ctypes uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; windll.kernel32.GetModuleHandleA(32)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">WindowsError: exception: access violation reading 0x00000020</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>只有None, integer, long, byte string和unicode string是可以直接用作这些函数参数的Python原生对象。None被传为C的NULL指针，byte string和unicode strings被传为指向含有它们数据的内存块的指针(char <em>或者wchar_t </em>)。integer和long被传为平台默认的C语言int类型，它们的值被调整来适应C类型。</p>
<h2 id="4-基本数据类型"><a href="#4-基本数据类型" class="headerlink" title="4. 基本数据类型"></a>4. 基本数据类型</h2><table>
<thead>
<tr>
<th style="text-align:left">ctypes type</th>
<th style="text-align:left">Ctype</th>
<th style="text-align:left">Python type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">c_bool</td>
<td style="text-align:left">_Bool</td>
<td style="text-align:left">bool(1)</td>
</tr>
<tr>
<td style="text-align:left">c_char</td>
<td style="text-align:left">char</td>
<td style="text-align:left">1-character string</td>
</tr>
<tr>
<td style="text-align:left">c_wchar</td>
<td style="text-align:left">wchar_t</td>
<td style="text-align:left">1-character unicode string</td>
</tr>
<tr>
<td style="text-align:left">c_byte</td>
<td style="text-align:left">char</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ubyte</td>
<td style="text-align:left">unsigned char</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_short</td>
<td style="text-align:left">short</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ushort</td>
<td style="text-align:left">unsigned short</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_int</td>
<td style="text-align:left">int</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_uint</td>
<td style="text-align:left">unsigned int</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_long</td>
<td style="text-align:left">long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ulong</td>
<td style="text-align:left">unsigned long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_longlong</td>
<td style="text-align:left">__int64 or long long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_ulonglong</td>
<td style="text-align:left">unsigned __int64 or unsigned long long</td>
<td style="text-align:left">int/long</td>
</tr>
<tr>
<td style="text-align:left">c_float</td>
<td style="text-align:left">float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_double</td>
<td style="text-align:left">double</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_longdouble</td>
<td style="text-align:left">long double</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">c_char_p</td>
<td style="text-align:left">char * (NUL terminated)</td>
<td style="text-align:left">string or None</td>
</tr>
<tr>
<td style="text-align:left">c_wchar_p</td>
<td style="text-align:left">wchar_t * (NUL terminated)</td>
<td style="text-align:left">unicode or None</td>
</tr>
<tr>
<td style="text-align:left">c_void_p</td>
<td style="text-align:left">void *</td>
<td style="text-align:left">int/long or None</td>
</tr>
</tbody>
</table>
<ol>
<li>构造函数接受任何with a truth value的对象</li>
</ol>
<p>All these types can be created by calling them with an optional initializer of the correct type and value:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c_int()</div><div class="line">c_long(0)</div><div class="line">&gt;&gt;&gt; c_char_p(&quot;Hello, World&quot;)</div><div class="line">c_char_p(&apos;Hello, World&apos;)</div><div class="line">&gt;&gt;&gt; c_ushort(-3)</div><div class="line">c_ushort(65533)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>值可变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int(42)</div><div class="line">&gt;&gt;&gt; print i</div><div class="line">c_long(42)</div><div class="line">&gt;&gt;&gt; print i.value</div><div class="line">42</div><div class="line">&gt;&gt;&gt; i.value = -99</div><div class="line">&gt;&gt;&gt; print i.value</div><div class="line">-99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>给指针类型(c_char_p, c_wchar_p和c_void_p)的实例赋新值，会改变指针的指向，不改变内存块的内容(当然不，因为Python的string是不可变的)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = &quot;Hello, World&quot;</div><div class="line">&gt;&gt;&gt; c_s = c_char_p(s)</div><div class="line">&gt;&gt;&gt; print c_s</div><div class="line">c_char_p(&apos;Hello, World&apos;)</div><div class="line">&gt;&gt;&gt; c_s.value = &quot;Hi, there&quot;</div><div class="line">&gt;&gt;&gt; print c_s</div><div class="line">c_char_p(&apos;Hi, there&apos;)</div><div class="line">&gt;&gt;&gt; print s					# first string is unchanged</div><div class="line">Hello, World</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>但是，你要小心，不要把它们传给期望指向可变内存的指针的函数。ctypes的create_string_buffer()函数可以以多种方式创建指向可变内存的指针。目前内存块的内容可以通过raw属性访问(或修改)。如果你想以NUL结尾的string访问，使用value属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; p = create_string_buffer(3)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">3 &apos;\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">6 &apos;Hello\x00&apos;</div><div class="line">&gt;&gt;&gt; print repr(p.value)</div><div class="line">&apos;Hello&apos;</div><div class="line">&gt;&gt;&gt; p = create_string_buffer(&quot;Hello&quot;, 10)</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">10 &apos;Hello\x00\x00\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt; p.value = &quot;Hi&quot;</div><div class="line">&gt;&gt;&gt; print sizeof(p), repr(p.raw)</div><div class="line">10 &apos;Hi\x00lo\x00\x00\x00\x00\x00&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>对应的是create_unicode_buffer()</p>
<h2 id="5-函数调用续"><a href="#5-函数调用续" class="headerlink" title="5. 函数调用续"></a>5. 函数调用续</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf = libc.printf</div><div class="line">&gt;&gt;&gt; printf(&quot;Hello, %s\n&quot;, &quot;World!&quot;)</div><div class="line">Hello, World!</div><div class="line">14</div><div class="line">&gt;&gt;&gt; printf(&quot;Hello, %S\n&quot;, u&quot;World!&quot;)</div><div class="line">Hello, World!</div><div class="line">14</div><div class="line">&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, 42)</div><div class="line">42 bottles of beer</div><div class="line">19</div><div class="line">&gt;&gt;&gt; printf(&quot;%f bottles of beer\n&quot;, 42.5)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: Don&apos;t know how to convert parameter 2</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>正如之前提到的，除了integer, string, unicode string以外所有Python类型必须被封装成对应的ctypes类型，这样它们可以被转换为需要的C数据类型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf(&quot;An int %d, a double %f\n&quot;, 1234, c_double(3.14))</div><div class="line">An int 1234, a double 3.140000</div><div class="line">31</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="6-使用自定义的数据类型调用函数"><a href="#6-使用自定义的数据类型调用函数" class="headerlink" title="6. 使用自定义的数据类型调用函数"></a>6. 使用自定义的数据类型调用函数</h2><p>你也可以自定义参数转换来允许你的类的实例被用作函数参数。ctypes寻找_as<em>parameter</em>属性，并用这个当作函数参数。当然，它必须是integer, string, unicode之一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Bottles(object):</div><div class="line">...     def __init__(self, number):</div><div class="line">...             self._as_parameter_ = number</div><div class="line">... </div><div class="line">&gt;&gt;&gt; bottles = Bottles(42)</div><div class="line">&gt;&gt;&gt; printf(&quot;%d bottles of beer\n&quot;, bottles)</div><div class="line">42 bottles of beer</div><div class="line">19</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="7-指定需要的参数类型-函数原型"><a href="#7-指定需要的参数类型-函数原型" class="headerlink" title="7. 指定需要的参数类型(函数原型)"></a>7. 指定需要的参数类型(函数原型)</h2><p>通过设置argtypes属性来指定从DLL导出的函数的参数类型是可能的。argtypes必须是C数据类型的序列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf.argtypes = [c_char_p, c_char_p, c_int, c_double]</div><div class="line">&gt;&gt;&gt; printf(&quot;String &apos;%s&apos;, Int %d, Double %f\n&quot;, &quot;Hi&quot;, 10, 2.2)</div><div class="line">String &apos;Hi&apos;, Int 10, Double 2.200000</div><div class="line">37</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指定形式可以防止不兼容参数类型(就像C函数的原型)，并且尝试转换参数为合法的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; printf(&quot;%d %d %d&quot;, 1, 2, 3)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: wrong type</div><div class="line">&gt;&gt;&gt; printf(&quot;%s %d %f\n&quot;, &quot;X&quot;, 2, 3)</div><div class="line">X 2 3.000000</div><div class="line">13</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>If you have defined your own classes which you pass to function calls, you have to implement a from_param() class method for them to be able to use them in the argtypes sequence. The from_param() class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its _as<em>parameter</em> attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, unicode, a ctypes instance, or an object with an _as<em>parameter</em> attribute.</p>
<h2 id="8-返回类型"><a href="#8-返回类型" class="headerlink" title="8. 返回类型"></a>8. 返回类型</h2><p>默认认为函数返回int类型。其他返回类型可以通过设置函数对象的restype属性来指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; strchr = libc.strchr</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))</div><div class="line">1701862487</div><div class="line">&gt;&gt;&gt; strchr.restype = c_char_p</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, ord(&quot;d&quot;))</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, ord(&quot;x&quot;))</div><div class="line">None</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>如果你想要避免上面的ord(“x”)调用，你可以设置argtypes属性，第二个参数从一个字符的Python string转换成一个C语言char:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; strchr.restype = c_char_p</div><div class="line">&gt;&gt;&gt; strchr.argtypes = [c_char_p, c_char]</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;def&quot;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ctypes.ArgumentError: argument 2: &lt;type &apos;exceptions.TypeError&apos;&gt;: wrong type</div><div class="line">&gt;&gt;&gt; print strchr(&quot;abcdef&quot;, &quot;x&quot;)</div><div class="line">None</div><div class="line">&gt;&gt;&gt; strchr(&quot;abcdef&quot;, &quot;d&quot;)</div><div class="line">&apos;def&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>你也可以使用一个可调用的Python对象(一个函数或一个类)作为restype的属性，如果外部函数返回一个整数。可调用对象的会被调用(使用C函数返回的整数作为参数)这个调用的结果会作为函数调用的结果。这对检查错误返回值和自动引发异常很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; GetModuleHandle = windll.kernel32.GetModuleHandleA</div><div class="line">&gt;&gt;&gt; def ValidHandle(value):</div><div class="line">...     if value == 0:</div><div class="line">...             raise WinError()</div><div class="line">...     return value</div><div class="line">...</div><div class="line">&gt;&gt;&gt; GetModuleHandle.restype = ValidHandle</div><div class="line">&gt;&gt;&gt; GetModuleHandle(None)</div><div class="line">478019584</div><div class="line">&gt;&gt;&gt; GetModuleHandle(&quot;something silly&quot;)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in ValidHandle</div><div class="line">WindowsError: [Error 126] 找不到指定的模块。</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>WinError is a function which will call Windows FormatMessage() api to get the string representation of an error code, and returns an exception. WinError takes an optional error code parameter, if no one is used, it calls GetLastError() to retrieve it.</p>
<p>Please note that a much more powerful error checking mechanism is available through the errcheck attribute; see the reference manual for details.</p>
<h2 id="9-传递指针-或者按引用传参"><a href="#9-传递指针-或者按引用传参" class="headerlink" title="9. 传递指针(或者按引用传参)"></a>9. 传递指针(或者按引用传参)</h2><p>ctypes导出byref()函数用于按引用传参。pointer()函数可以达到同样的效果，虽然pointer会做许多更多的工作，因为它会构造一个真的指针对象，所以如果你在python中不需要指针对象，用byref()更快。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int()</div><div class="line">&gt;&gt;&gt; f = c_float()</div><div class="line">&gt;&gt;&gt; s = create_string_buffer(&quot;\000&quot; * 32)</div><div class="line">&gt;&gt;&gt; print i.value, f.value, repr(s.value)</div><div class="line">0 0.0 &apos;&apos;</div><div class="line">&gt;&gt;&gt; libc.sscanf(&quot;1 3.14 Hello&quot;, &quot;%d %f %s&quot;, byref(i), byref(f), s)</div><div class="line">3</div><div class="line">&gt;&gt;&gt; print i.value, f.value, repr(s.value)</div><div class="line">1 3.1400001049 &apos;Hello&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="10-结构体和联合"><a href="#10-结构体和联合" class="headerlink" title="10. 结构体和联合"></a>10. 结构体和联合</h2><p>结构体和联合一定是从ctypes定义的Structure和Union基类衍生而来。每个子类一定要定义<em>fields</em>属性。<em>fields</em>一定是两个元组的列表，包含字段名和字段类型。</p>
<p>字段类型一定是ctypes类型比如c_int或者其他ctypes衍生类型:structure, union, array, pointer.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = [(&quot;x&quot;, c_int),</div><div class="line">...                 (&quot;y&quot;, c_int)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; point = POINT(10, 20)</div><div class="line">&gt;&gt;&gt; print(point.x, point.y)</div><div class="line">(10, 20)</div><div class="line">&gt;&gt;&gt; point = POINT(y=5)</div><div class="line">&gt;&gt;&gt; print(point.x, point.y)</div><div class="line">(0, 5)</div><div class="line">&gt;&gt;&gt; POINT(1, 2, 3)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: too many initializers</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>你可以将结构体作为字段类型来构造更复杂的结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = [(&quot;upperleft&quot;, POINT),]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = [(&quot;upperleft&quot;, POINT),</div><div class="line">...                 (&quot;lowerright&quot;, POINT)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; rc = RECT(point)</div><div class="line">&gt;&gt;&gt; print(rc.upperleft.x, rc.upperleft.y)</div><div class="line">(0, 5)</div><div class="line">&gt;&gt;&gt; print(rc.lowerright.x, rc.lowerright.y)</div><div class="line">(0, 0)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>嵌套的结构体可以以多种方式初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; r = RECT(POINT(1, 2), POINT(3, 4))</div><div class="line">&gt;&gt;&gt; r = RECT((1, 2), (3, 4))</div></pre></td></tr></table></figure></p>
<p>Field descriptors can be retrieved from the class, they are useful for debugging because they can provide useful information:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(POINT.x)</div><div class="line">&lt;Field type=c_long, ofs=0, size=4&gt;</div><div class="line">&gt;&gt;&gt; print(POINT.y)</div><div class="line">&lt;Field type=c_long, ofs=4, size=4&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Warning</p>
<p>ctypes does not support passing unions or structures with bit-fields to functions by value. While this may work on 32-bit x86, it’s not guaranteed by the library to work in the general case. Unions and structures with bit-fields should always be passed to functions by pointer. </p>
<h2 id="11-结构体-联合对齐和字节顺序"><a href="#11-结构体-联合对齐和字节顺序" class="headerlink" title="11. 结构体/联合对齐和字节顺序"></a>11. 结构体/联合对齐和字节顺序</h2><p>By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior be specifying a <em>pack</em> class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what #pragma pack(n) also does in MSVC.</p>
<p>ctypes uses the native byte order for Structures and Unions. To build structures with non-native byte order, you can use one of the BigEndianStructure, LittleEndianStructure, BigEndianUnion, and LittleEndianUnion base classes. These classes cannot contain pointer fields.</p>
<h2 id="12-结构体和联合中的bit字段"><a href="#12-结构体和联合中的bit字段" class="headerlink" title="12. 结构体和联合中的bit字段"></a>12. 结构体和联合中的bit字段</h2><p>创建含有bit字段的结构体和联合是可能的。只有对integer字段有可能，bit的宽带由<em>fields</em>元组的第三项指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Int(Structure):</div><div class="line">...     _fields_ = [(&quot;first_16&quot;, c_int, 16),</div><div class="line">...                 (&quot;second_16&quot;, c_int, 16)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print(Int.first_16)</div><div class="line">&lt;Field type=c_long, ofs=0:0, bits=16&gt;</div><div class="line">&gt;&gt;&gt; print(Int.second_16)</div><div class="line">&lt;Field type=c_long, ofs=0:16, bits=16&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="13-数组"><a href="#13-数组" class="headerlink" title="13. 数组"></a>13. 数组</h2><p>推荐的创建数组的方式是将一个数据类型乘以一个正整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; TenPointsArrayType = POINT * 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class MyStruct(Structure):</div><div class="line">...     _fields_ = [(&quot;a&quot;, c_int),</div><div class="line">...                 (&quot;b&quot;, c_float),</div><div class="line">...                 (&quot;point_array&quot;, POINT * 4)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; print(len(MyStruct().point_array))</div><div class="line">4</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>调用类来创建实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr = TenPointsArrayType()</div><div class="line">for pt in arr:</div><div class="line">    print(pt.x, pt.y)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; TenIntegers = c_int * 10</div><div class="line">&gt;&gt;&gt; ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</div><div class="line">&gt;&gt;&gt; print(ii)</div><div class="line">&lt;__main__.c_long_Array_10 object at 0x025A4490&gt;</div><div class="line">&gt;&gt;&gt; for i in ii: print i,</div><div class="line">...</div><div class="line">1 2 3 4 5 6 7 8 9 10</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="14-指针"><a href="#14-指针" class="headerlink" title="14. 指针"></a>14. 指针</h2><p>调用pointer()来创建指针实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; i = c_int(42)</div><div class="line">&gt;&gt;&gt; pi = pointer(i)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指针实例有contents属性来返回指针所指的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi.contents</div><div class="line">c_long(42)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>contents返回的不是原始对象，而是新构造的等价的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi.contents is i</div><div class="line">False</div><div class="line">&gt;&gt;&gt; pi.contents is pi.contents</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>给指针的contents属性赋予另一个c_int实例，会改变指针的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; i = c_int(99)</div><div class="line">&gt;&gt;&gt; pi.contents = i</div><div class="line">&gt;&gt;&gt; pi.contents</div><div class="line">c_long(99)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>指针对象也可以用整数索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; pi[0]</div><div class="line">99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>用索引赋值会改变指针指向的对象的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(i)</div><div class="line">c_long(99)</div><div class="line">&gt;&gt;&gt; pi[0] = 22</div><div class="line">&gt;&gt;&gt; print(i)</div><div class="line">c_long(22)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>pointer()不只是简单创建指针实例，它会先创建指针类型。通过调用POINTER()函数来完成。POINTER()接受任何ctypes类型，并返回新类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; PI = POINTER(c_int)</div><div class="line">&gt;&gt;&gt; PI</div><div class="line">&lt;class &apos;__main__.LP_c_long&apos;&gt;</div><div class="line">&gt;&gt;&gt; PI(42)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: expected c_long instead of int</div><div class="line">&gt;&gt;&gt; PI(c_int(42))</div><div class="line">&lt;__main__.LP_c_long object at 0x025A4530&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>不使用参数调用指针类型会创建NULL指针，NULL指针的布尔值是False。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; null_ptr = POINTER(c_int)()</div><div class="line">&gt;&gt;&gt; print(bool(null_ptr))</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>ctypes解引用指针时会检查指针是否为NULL(但是解引用非法的非空指针会使Python崩溃)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; null_ptr[0]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: NULL pointer access</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; null_ptr[0] = 1234</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: NULL pointer access</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="15-类型转换"><a href="#15-类型转换" class="headerlink" title="15. 类型转换"></a>15. 类型转换</h2><p>对于POINTER(c_int)，ctypes接受c_int数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Bar(Structure):</div><div class="line">...     _fields_ = [(&quot;count&quot;, c_int), (&quot;value&quot;, POINTER(c_int))]</div><div class="line">...</div><div class="line">&gt;&gt;&gt; bar = Bar()</div><div class="line">&gt;&gt;&gt; bar.values = (c_int * 3)(1, 2, 3)</div><div class="line">&gt;&gt;&gt; bar.count = 3</div><div class="line">&gt;&gt;&gt; for i in range(bar.count):</div><div class="line">...     print(bar.values[i])</div><div class="line">...</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>你可以赋值None来将指针类型的字段设置为NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; bar.values = None</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>不兼容的类型会报错，可以使用cast()函数强制转换。cast()接受2个参数，一个ctypes对象是或者可以被转化为类似指针和一个ctypes指针类型。返回指向第一个参数所指内存的第二个参数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = (c_byte * 4)()</div><div class="line">&gt;&gt;&gt; cast(a, POINTER(c_int))</div><div class="line">&lt;__main__.LP_c_long object at 0x025A43F0&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="16-未完成类型"><a href="#16-未完成类型" class="headerlink" title="16. 未完成类型"></a>16. 未完成类型</h2><p>可以先定义类，再设置<em>fields</em>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class cell(Structure):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; cell._fields_ = [(&quot;name&quot;, c_char_p),</div><div class="line">...                  (&quot;next&quot;, POINTER(cell))]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; c1 = cell()</div><div class="line">&gt;&gt;&gt; c1.name = &quot;foo&quot;</div><div class="line">&gt;&gt;&gt; c2 = cell()</div><div class="line">&gt;&gt;&gt; c2.name = &quot;bar&quot;</div><div class="line">&gt;&gt;&gt; c1.next = pointer(c2)</div><div class="line">&gt;&gt;&gt; c2.next = pointer(c1)</div><div class="line">&gt;&gt;&gt; p = c1</div><div class="line">&gt;&gt;&gt; for i in range(8):</div><div class="line">...     print p.name,</div><div class="line">...     p = p.next[0]</div><div class="line">...</div><div class="line">foo bar foo bar foo bar foo bar</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="17-回调函数"><a href="#17-回调函数" class="headerlink" title="17. 回调函数"></a>17. 回调函数</h2><p>ctypes允许从Python可调用对象创建C可调用函数指针。有时叫回调函数。<br>首先，你一定要为回调函数创建一个类。该类知道调用约定，返回类型，参数数量和类型。<br>CFUNCTYPE()工厂函数创建使用cdecl调用约定的回调函数。<br>WINFUNCTYPE()工厂函数创建使用stdcall调用约定的回调函数。<br>这些工厂函数使用结果类型作为第一个参数，参数类型作为剩下的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; IntArray5 = c_int * 5</div><div class="line">&gt;&gt;&gt; ia = IntArray5(5, 1, 7, 33, 99)</div><div class="line">&gt;&gt;&gt; qsort = libc.qsort</div><div class="line">&gt;&gt;&gt; qsort.restype = None</div><div class="line">&gt;&gt;&gt; </div><div class="line">&gt;&gt;&gt; CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))</div><div class="line">&gt;&gt;&gt; def py_cmp_func(a, b):</div><div class="line">...     print(&quot;py_cmp_func&quot;, a[0], b[0])</div><div class="line">...     return a[0] - b[0]</div><div class="line">... </div><div class="line">&gt;&gt;&gt; qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func))</div><div class="line">(&apos;py_cmp_func&apos;, 5, 1)</div><div class="line">(&apos;py_cmp_func&apos;, 33, 99)</div><div class="line">(&apos;py_cmp_func&apos;, 7, 33)</div><div class="line">(&apos;py_cmp_func&apos;, 1, 7)</div><div class="line">(&apos;py_cmp_func&apos;, 5, 7)</div><div class="line">&gt;&gt;&gt; for i in ia: print i,</div><div class="line">... </div><div class="line">1 5 7 33 99</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>Note: Make sure you keep references to CFUNCTYPE() objects as long as they are used from C code. ctypes doesn’t, and if you don’t, they may be garbage collected, crashing your program when a callback is made.</p>
<p>Also, note that if the callback function is called in a thread created outside of Python’s control (e.g. by the foreign code that calls the callback), ctypes creates a new dummy Python thread on every invocation. This behavior is correct for most purposes, but it means that values stored with threading.local will not survive across different callbacks, even when those calls are made from the same C thread.</p>
<h2 id="18-访问dll导出的值"><a href="#18-访问dll导出的值" class="headerlink" title="18. 访问dll导出的值"></a>18. 访问dll导出的值</h2><p>Some shared libraries not only export functions, they also export variables. An example in the Python library itself is the Py_OptimizeFlag, an integer set to 0, 1, or 2, depending on the -O or -OO flag given on startup.</p>
<p>ctypes can access values like this with the in_dll() class methods of the type. pythonapi is a predefined symbol giving access to the Python C api:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; opt_flag = c_int.in_dll(pythonapi, &quot;Py_OptimizeFlag&quot;)</div><div class="line">&gt;&gt;&gt; print(opt_flag)</div><div class="line">c_long(0)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>If the interpreter would have been started with -O, the sample would have printed c_long(1), or c_long(2) if -OO would have been specified.</p>
<p>An extended example which also demonstrates the use of pointers accesses the PyImport_FrozenModules pointer exported by Python.</p>
<p>Quoting the docs for that value:</p>
<pre><code>This pointer is initialized to point to an array of struct _frozen records, terminated by one whose members are all NULL or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules.
</code></pre><p>So manipulating this pointer could even prove useful. To restrict the example size, we show only how this table can be read with ctypes:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; class struct_frozen(Structure):</div><div class="line">...     _fields_ = [(&quot;name&quot;, c_char_p),</div><div class="line">...                 (&quot;code&quot;, POINTER(c_ubyte)),</div><div class="line">...                 (&quot;size&quot;, c_int)]</div><div class="line">...</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>We have defined the struct _frozen data type, so we can get the pointer to the table:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; FrozenTable = POINTER(struct_frozen)</div><div class="line">&gt;&gt;&gt; table = FrozenTable.in_dll(pythonapi, &quot;PyImport_FrozenModules&quot;)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Since table is a pointer to the array of struct_frozen records, we can iterate over it, but we just have to make sure that our loop terminates, because pointers have no size. Sooner or later it would probably crash with an access violation or whatever, so it’s better to break out of the loop when we hit the NULL entry:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; for item in table:</div><div class="line">...     if item.name is None:</div><div class="line">...         break</div><div class="line">...     print(item.name.decode(&quot;ascii&quot;), item.size)</div><div class="line">...</div><div class="line">_frozen_importlib 31764</div><div class="line">_frozen_importlib_external 41499</div><div class="line">__hello__ 161</div><div class="line">__phello__ -161</div><div class="line">__phello__.spam 161</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>The fact that standard Python has a frozen module and a frozen package (indicated by the negative size member) is not well known, it is only used for testing. Try it out with import <strong>hello</strong> for example.</p>
<h2 id="19-惊喜"><a href="#19-惊喜" class="headerlink" title="19. 惊喜"></a>19. 惊喜</h2><p>There are some edges in ctypes where you might expect something other than what actually happens.</p>
<p>Consider the following example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from ctypes import *</div><div class="line">&gt;&gt;&gt; class POINT(Structure):</div><div class="line">...     _fields_ = (&quot;x&quot;, c_int), (&quot;y&quot;, c_int)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class RECT(Structure):</div><div class="line">...     _fields_ = (&quot;a&quot;, POINT), (&quot;b&quot;, POINT)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; p1 = POINT(1, 2)</div><div class="line">&gt;&gt;&gt; p2 = POINT(3, 4)</div><div class="line">&gt;&gt;&gt; rc = RECT(p1, p2)</div><div class="line">&gt;&gt;&gt; print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)</div><div class="line">1 2 3 4</div><div class="line">&gt;&gt;&gt; # now swap the two points</div><div class="line">&gt;&gt;&gt; rc.a, rc.b = rc.b, rc.a</div><div class="line">&gt;&gt;&gt; print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)</div><div class="line">3 4 3 4</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Hm. We certainly expected the last statement to print 3 4 1 2. What happened? Here are the steps of the rc.a, rc.b = rc.b, rc.a line above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; temp0, temp1 = rc.b, rc.a</div><div class="line">&gt;&gt;&gt; rc.a = temp0</div><div class="line">&gt;&gt;&gt; rc.b = temp1</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Note that temp0 and temp1 are objects still using the internal buffer of the rc object above. So executing rc.a = temp0 copies the buffer contents of temp0 into rc ‘s buffer. This, in turn, changes the contents of temp1. So, the last assignment rc.b = temp1, doesn’t have the expected effect.</p>
<p>Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn’t copy the sub-object, instead it retrieves a wrapper object accessing the root-object’s underlying buffer.</p>
<p>Another example that may behave different from what one would expect is this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = c_char_p()</div><div class="line">&gt;&gt;&gt; s.value = &quot;abc def ghi&quot;</div><div class="line">&gt;&gt;&gt; s.value</div><div class="line">&apos;abc def ghi&apos;</div><div class="line">&gt;&gt;&gt; s.value is s.value</div><div class="line">False</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Why is it printing False? ctypes instances are objects containing a memory block plus some descriptors accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the contents of the object is stored. Accessing the contents again constructs a new Python object each time!</p>
<h2 id="20-大小可变的数据类型"><a href="#20-大小可变的数据类型" class="headerlink" title="20. 大小可变的数据类型"></a>20. 大小可变的数据类型</h2><p>ctypes对大小可变的数组和结构体提供一些支持。<br>resize()函数可以对已经存在的类型对象重新设置内存大小。对象是第一个参数，字节大小是第二个参数。不能将内存大小设置得比对象类型原始大小小，否则会引发ValueError错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; short_array = (c_short * 4)()</div><div class="line">&gt;&gt;&gt; print(sizeof(short_array))</div><div class="line">8</div><div class="line">&gt;&gt;&gt; resize(short_array, 4)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">ValueError: minimum size is 8</div><div class="line">&gt;&gt;&gt; resize(short_array, 32)</div><div class="line">&gt;&gt;&gt; sizeof(short_array)</div><div class="line">32</div><div class="line">&gt;&gt;&gt; sizeof(type(short_array))</div><div class="line">8</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>无法访问多出来的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; short_array[:]</div><div class="line">[0, 0, 0, 0]</div><div class="line">&gt;&gt;&gt; short_array[7]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">IndexError: invalid index</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>也可以通过使用Python的动态特性和在知道需要内存大小后(重新)定义数据类型来使用大小可变的数据类型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blackhatpythongit.github.io/2016/08/13/ctypes/" data-id="cis4s6g1z00016ghm9lt1q3j4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/21/Git/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Git
        
      </div>
    </a>
  
  
    <a href="/2016/08/07/恶意代码混淆技术/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">恶意代码混淆技术</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/21/Git/">Git</a>
          </li>
        
          <li>
            <a href="/2016/08/13/ctypes/">ctypes tutorial</a>
          </li>
        
          <li>
            <a href="/2016/08/07/恶意代码混淆技术/">恶意代码混淆技术</a>
          </li>
        
          <li>
            <a href="/2016/08/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Nob<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>